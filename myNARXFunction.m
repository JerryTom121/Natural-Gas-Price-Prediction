function [Y,Xf,Af] = myNARXFunction(X,Xi,~)
%MYNARXFUNCTION neural network simulation function.
%
% Generated by Neural Network Toolbox function genFunction, 04-May-2016 10:49:17.
% 
% [Y,Xf,Af] = myNARXFunction(X,Xi,~) takes these arguments:
% 
%   X = 2xTS cell, 2 inputs over TS timesteps
%   Each X{1,ts} = 4xQ matrix, input #1 at timestep ts.
%   Each X{2,ts} = 1xQ matrix, input #2 at timestep ts.
% 
%   Xi = 2x9 cell 2, initial 9 input delay states.
%   Each Xi{1,ts} = 4xQ matrix, initial states for input #1.
%   Each Xi{2,ts} = 1xQ matrix, initial states for input #2.
% 
%   Ai = 2x0 cell 2, initial 9 layer delay states.
%   Each Ai{1,ts} = 6xQ matrix, initial states for layer #1.
%   Each Ai{2,ts} = 1xQ matrix, initial states for layer #2.
% 
% and returns:
%   Y = 1xTS cell of 2 outputs over TS timesteps.
%   Each Y{1,ts} = 1xQ matrix, output #1 at timestep ts.
% 
%   Xf = 2x9 cell 2, final 9 input delay states.
%   Each Xf{1,ts} = 4xQ matrix, final states for input #1.
%   Each Xf{2,ts} = 1xQ matrix, final states for input #2.
% 
%   Af = 2x0 cell 2, final 0 layer delay states.
%   Each Af{1ts} = 6xQ matrix, final states for layer #1.
%   Each Af{2ts} = 1xQ matrix, final states for layer #2.
% 
% where Q is number of samples (or series) and TS is the number of timesteps.

%#ok<*RPMT0>

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1_xoffset = [1766603;1368369;84;30556];
x1_step1_gain = [1.89376544010635e-06;1.08052504873168e-06;0.00896860986547085;1.98350910529855e-06];
x1_step1_ymin = -1;

% Input 2
x2_step1_xoffset = 1.72;
x2_step1_gain = 0.170940170940171;
x2_step1_ymin = -1;

% Layer 1
b1 = [-2.6968190694445564;8.4465880255162489;1.5580386100138872;-0.78891173923018143;0.67368913705166789;-0.03386345717832992];
IW1_1 = [-7.2061578370245556 1.3577116023718363 -6.0059453026585405 3.7731842214821958;-0.65547252808258294 3.2036635768787485 0.52585912833388071 11.230940741860831;-6.2431307923385084 10.350059772792143 1.541477783639466 -13.989988914580159;4.9834788143212352 3.1290041174324852 -0.95326305568915015 -2.3178193246565986;0.23491832031023802 -0.42736727839619093 0.69065003233189426 0.62567427234389039;-0.42871439839452002 1.3980220312379938 1.130613376875049 -0.65872595619855567];
IW1_2 = [-10.62434720733202 2.723054318652109 1.396947627225734 -12.424484590399347 -3.0267581583068042 -2.9699908323961695 6.0764119586069105 10.882533751526559 8.0003238598951167;6.2898354561273111 -3.1604965059467611 14.000808805356666 -12.723597687928436 8.4459981132555768 -5.4548392242871966 -9.9438826058252268 -1.7704534459218977 1.696035808290616;5.1537850238451188 -12.541446882733219 -5.9111898756028154 -7.0310964843084864 8.9744289694875992 7.4855736118520877 13.866994969144342 -9.7639624985542728 10.212750082412951;-3.0846040065670257 1.906242682864999 3.4179131139669403 -4.5486774777273791 -2.7633253395354691 1.6707336466605127 -2.2534518939803214 -0.28575620826021625 3.3497895282681989;-0.096979503004799461 0.84297721118192515 0.62946002083634944 0.97118246062447477 -0.30295954414093779 0.10342166079690607 -0.57234931320276439 0.030399268829154225 0.41457708782223551;-3.9436273946788662 0.70807273427153317 0.53064256052375414 0.72733771299182115 0.4420218972652814 0.23620591845215011 0.28276799440348394 0.46289800721918251 0.085726989745045723];

% Layer 2
b2 = -0.23739610102609202;
LW2_1 = [0.0064782305361632533 0.021834807681098242 0.064523359650596301 -0.018653464085804473 0.49768173324315335 -0.32864603826073113];

% Output 1
y1_step1_ymin = -1;
y1_step1_gain = 0.170940170940171;
y1_step1_xoffset = 1.72;

% ===== SIMULATION ========

% Format Input Arguments
isCellX = iscell(X);
if ~isCellX, X = {X}; end;
if (nargin < 2), error('Initial input states Xi argument needed.'); end

% Dimensions
TS = size(X,2); % timesteps
if ~isempty(X)
    Q = size(X{1},2); % samples/series
elseif ~isempty(Xi)
    Q = size(Xi{1},2);
else
    Q = 0;
end

% Input 1 Delay States
Xd1 = cell(1,10);
for ts=1:9
    Xd1{ts} = mapminmax_apply(Xi{1,ts},x1_step1_gain,x1_step1_xoffset,x1_step1_ymin);
end

% Input 2 Delay States
Xd2 = cell(1,10);
for ts=1:9
    Xd2{ts} = mapminmax_apply(Xi{2,ts},x2_step1_gain,x2_step1_xoffset,x2_step1_ymin);
end

% Allocate Outputs
Y = cell(1,TS);

% Time loop
for ts=1:TS

    % Rotating delay state position
    xdts = mod(ts+8,10)+1;
    
    % Input 1
    Xd1{xdts} = mapminmax_apply(X{1,ts},x1_step1_gain,x1_step1_xoffset,x1_step1_ymin);
    
    % Input 2
    Xd2{xdts} = mapminmax_apply(X{2,ts},x2_step1_gain,x2_step1_xoffset,x2_step1_ymin);
    
    % Layer 1
    tapdelay1 = cat(1,Xd1{mod(xdts-1-1,10)+1});
    tapdelay2 = cat(1,Xd2{mod(xdts-[1 2 3 4 5 6 7 8 9]-1,10)+1});
    a1 = tansig_apply(repmat(b1,1,Q) + IW1_1*tapdelay1 + IW1_2*tapdelay2);
    
    % Layer 2
    a2 = repmat(b2,1,Q) + LW2_1*a1;
    
    % Output 1
    Y{1,ts} = mapminmax_reverse(a2,y1_step1_gain,y1_step1_xoffset,y1_step1_ymin);
end

% Final Delay States
finalxts = TS+(1: 9);
xits = finalxts(finalxts<=9);
xts = finalxts(finalxts>9)-9;
Xf = [Xi(:,xits) X(:,xts)];
Af = cell(2,0);

% Format Output Arguments
if ~isCellX, Y = cell2mat(Y); end
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings_gain,settings_xoffset,settings_ymin)
y = bsxfun(@minus,x,settings_xoffset);
y = bsxfun(@times,y,settings_gain);
y = bsxfun(@plus,y,settings_ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n)
a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings_gain,settings_xoffset,settings_ymin)
x = bsxfun(@minus,y,settings_ymin);
x = bsxfun(@rdivide,x,settings_gain);
x = bsxfun(@plus,x,settings_xoffset);
end
