function [Y,Xf,Af] = myNARFunction(X,Xi,~)
%MYNARFUNCTION neural network simulation function.
%
% Generated by Neural Network Toolbox function genFunction, 03-May-2016 23:14:29.
% 
% [Y,Xf,Af] = myNARFunction(X,Xi,~) takes these arguments:
% 
%   X = 1xTS cell, 1 inputs over TS timesteps
%   Each X{1,ts} = 1xQ matrix, input #1 at timestep ts.
% 
%   Xi = 1x10 cell 1, initial 10 input delay states.
%   Each Xi{1,ts} = 1xQ matrix, initial states for input #1.
% 
%   Ai = 2x0 cell 2, initial 10 layer delay states.
%   Each Ai{1,ts} = 6xQ matrix, initial states for layer #1.
%   Each Ai{2,ts} = 1xQ matrix, initial states for layer #2.
% 
% and returns:
%   Y = 1xTS cell of 1 outputs over TS timesteps.
%   Each Y{1,ts} = 1xQ matrix, output #1 at timestep ts.
% 
%   Xf = 1x10 cell 1, final 10 input delay states.
%   Each Xf{1,ts} = 1xQ matrix, final states for input #1.
% 
%   Af = 2x0 cell 2, final 0 layer delay states.
%   Each Af{1ts} = 6xQ matrix, final states for layer #1.
%   Each Af{2ts} = 1xQ matrix, final states for layer #2.
% 
% where Q is number of samples (or series) and TS is the number of timesteps.

%#ok<*RPMT0>

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1_xoffset = 1.72;
x1_step1_gain = 0.170940170940171;
x1_step1_ymin = -1;

% Layer 1
b1 = [-2.0684414976786618;-0.928058766264795;0.74382363513050664;-0.83794117142663538;0.93541351314753762;-2.9328597496722084];
IW1_1 = [-0.28262872577269527 -0.61957937835365962 1.3973518152750335 1.272984065359468 0.37069067479039686 -0.22413015328900715 0.023728856809263323 -0.12022120074113758 0.2830408724660145 -0.31157341827593221;1.9587230155374691 0.13580754893639194 -0.061618485230272635 0.90898140833761298 -0.13978570049784042 1.6950897181888576 -0.88388354449183082 1.2796857412716542 2.7777692266307668 -0.1720331678403223;1.947965696327191 -1.2939515593741269 0.43884304241404409 0.52360886680920316 -0.14935760614812077 -0.15853969672465629 -0.44690555015394473 0.38333585075362164 -0.047221563125979998 0.28390117952915567;1.301313749985987 1.7107303415815012 -0.065035599073635431 -0.78782389171144818 -0.43631185251127136 0.78895066167808214 0.066169271840840482 0.78627653807003239 0.26263675525256225 0.37052905840473804;0.17826185465448291 1.223325901978519 0.052205476217516811 -0.48581552481748336 -0.55129489748190852 1.2902802430749514 0.36893073234362667 -0.56619463319866203 -0.6370607021969853 -0.050475578841285729;-1.288685194217364 -0.69412996249868542 0.29050866815676279 0.39984119825810466 -0.56611277490201362 0.18741678467395187 -0.10343113634162274 0.46181807716151008 -0.21210265854767898 0.21930389246193457];

% Layer 2
b2 = -0.83955538790064521;
LW2_1 = [-0.068909037183156954 -0.19885838731973568 0.55767810884680258 0.52914496576747627 0.31241461518805269 -0.48992708103002008];

% Output 1
y1_step1_ymin = -1;
y1_step1_gain = 0.170940170940171;
y1_step1_xoffset = 1.72;

% ===== SIMULATION ========

% Format Input Arguments
isCellX = iscell(X);
if ~isCellX, X = {X}; end;
if (nargin < 2), error('Initial input states Xi argument needed.'); end

% Dimensions
TS = size(X,2); % timesteps
if ~isempty(X)
    Q = size(X{1},2); % samples/series
elseif ~isempty(Xi)
    Q = size(Xi{1},2);
else
    Q = 0;
end

% Input 1 Delay States
Xd1 = cell(1,11);
for ts=1:10
    Xd1{ts} = mapminmax_apply(Xi{1,ts},x1_step1_gain,x1_step1_xoffset,x1_step1_ymin);
end

% Allocate Outputs
Y = cell(1,TS);

% Time loop
for ts=1:TS

    % Rotating delay state position
    xdts = mod(ts+9,11)+1;
    
    % Input 1
    Xd1{xdts} = mapminmax_apply(X{1,ts},x1_step1_gain,x1_step1_xoffset,x1_step1_ymin);
    
    % Layer 1
    tapdelay1 = cat(1,Xd1{mod(xdts-[1 2 3 4 5 6 7 8 9 10]-1,11)+1});
    a1 = tansig_apply(repmat(b1,1,Q) + IW1_1*tapdelay1);
    
    % Layer 2
    a2 = repmat(b2,1,Q) + LW2_1*a1;
    
    % Output 1
    Y{1,ts} = mapminmax_reverse(a2,y1_step1_gain,y1_step1_xoffset,y1_step1_ymin);
end

% Final Delay States
finalxts = TS+(1: 10);
xits = finalxts(finalxts<=10);
xts = finalxts(finalxts>10)-10;
Xf = [Xi(:,xits) X(:,xts)];
Af = cell(2,0);

% Format Output Arguments
if ~isCellX, Y = cell2mat(Y); end
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings_gain,settings_xoffset,settings_ymin)
y = bsxfun(@minus,x,settings_xoffset);
y = bsxfun(@times,y,settings_gain);
y = bsxfun(@plus,y,settings_ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n)
a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings_gain,settings_xoffset,settings_ymin)
x = bsxfun(@minus,y,settings_ymin);
x = bsxfun(@rdivide,x,settings_gain);
x = bsxfun(@plus,x,settings_xoffset);
end
